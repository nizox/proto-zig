///! Generate Zig source code with MiniTable definitions from FileInfo.

const std = @import("std");
const Allocator = std.mem.Allocator;
const proto = @import("proto");
const FieldType = proto.FieldType;
const Mode = proto.FieldMode;

const descriptor_parser = @import("descriptor_parser.zig");
const FileInfo = descriptor_parser.FileInfo;
const MessageInfo = descriptor_parser.MessageInfo;
const EnumInfo = descriptor_parser.EnumInfo;
const FieldInfo = descriptor_parser.FieldInfo;
const LayoutInfo = descriptor_parser.LayoutInfo;

const names = @import("names.zig");

/// Generated file content.
pub const GeneratedFile = struct {
    name: []const u8,
    content: []const u8,
};

/// Generate Zig source code for a .proto file.
pub fn generateFile(file: FileInfo, allocator: Allocator) !GeneratedFile {
    var buf: std.ArrayList(u8) = .empty;
    errdefer buf.deinit(allocator);

    const writer = buf.writer(allocator);

    // File header
    try writer.writeAll("// Generated by protoc-gen-zig-pb. DO NOT EDIT.\n");
    try writer.print("//! MiniTables for {s}\n\n", .{file.name});

    // Imports
    try writer.writeAll("const proto = @import(\"proto\");\n");
    try writer.writeAll("const MiniTable = proto.MiniTable;\n");
    try writer.writeAll("const MiniTableField = proto.MiniTableField;\n");
    try writer.writeAll("const FieldType = proto.FieldType;\n");
    try writer.writeAll("const Mode = proto.Mode;\n\n");

    // Generate enums
    for (file.enums) |enum_info| {
        try generateEnum(enum_info, writer, allocator);
    }

    // Generate messages (depth-first, to handle nested messages)
    for (file.messages) |msg| {
        try generateMessage(msg, writer, allocator);
    }

    // Generate filename
    const base_name = std.fs.path.basename(file.name);
    const name_no_ext = if (std.mem.endsWith(u8, base_name, ".proto"))
        base_name[0 .. base_name.len - 6]
    else
        base_name;

    const gen_name = try std.fmt.allocPrint(allocator, "{s}.pb.zig", .{name_no_ext});

    return GeneratedFile{
        .name = gen_name,
        .content = try buf.toOwnedSlice(allocator),
    };
}

/// Generate enum definition.
fn generateEnum(enum_info: EnumInfo, writer: anytype, allocator: Allocator) !void {
    const enum_name = try names.toSnakeCase(allocator, enum_info.name);
    defer allocator.free(enum_name);

    try writer.print("// {s}\n\n", .{enum_info.full_name});
    try writer.print("pub const {s} = enum(i32) {{\n", .{enum_name});

    for (enum_info.values) |value| {
        const value_name = try names.toSnakeCase(allocator, value.name);
        defer allocator.free(value_name);
        try writer.print("    {s} = {d},\n", .{ value_name, value.number });
    }

    try writer.writeAll("};\n\n");
}

/// Generate message and all nested messages (depth-first).
fn generateMessage(msg: MessageInfo, writer: anytype, allocator: Allocator) !void {
    // Generate nested enums first
    for (msg.nested_enums) |nested_enum| {
        try generateEnum(nested_enum, writer, allocator);
    }

    // Generate nested messages recursively (depth-first)
    for (msg.nested_messages) |nested| {
        try generateMessage(nested, writer, allocator);
    }

    // Generate this message
    const msg_name = try names.toSnakeCase(allocator, msg.name);
    defer allocator.free(msg_name);

    try writer.print("// {s}\n\n", .{msg.full_name});

    // Check if this is a self-referencing message
    const is_self_ref = isSelfReferencing(msg);

    // Generate fields array
    if (msg.layout) |layout| {
        if (layout.fields.len > 0) {
            try writer.print("const {s}_fields = [_]MiniTableField{{\n", .{msg_name});
            for (layout.fields) |field| {
                try writer.writeAll("    .{\n");
                try writer.print("        .number = {d},\n", .{field.number});
                try writer.print("        .offset = {d},\n", .{field.offset});
                try writer.print("        .presence = {d},\n", .{field.presence});
                try writer.print("        .submsg_index = {d},\n", .{field.submsg_index});
                try writer.print("        .field_type = .{s},\n", .{@tagName(field.field_type)});
                try writer.print("        .mode = .{s},\n", .{@tagName(field.mode)});
                try writer.print("        .is_packed = {s},\n", .{if (field.is_packed) "true" else "false"});
                try writer.writeAll("    },\n");
            }
            try writer.writeAll("};\n\n");
        } else {
            try writer.print("const {s}_fields = [_]MiniTableField{{}};\n\n", .{msg_name});
        }

        // Generate submessages array
        if (msg.submessages_array.len > 0) {
            try writer.print("const {s}_submessages = [_]*const MiniTable{{\n", .{msg_name});
            for (msg.submessages_array) |submsg_full_name| {
                const simple_name = names.extractSimpleName(submsg_full_name);
                const submsg_table_name = try names.messageTableName(allocator, simple_name);
                defer allocator.free(submsg_table_name);
                try writer.print("    &{s},\n", .{submsg_table_name});
            }
            try writer.writeAll("};\n\n");
        } else {
            try writer.print("const {s}_submessages = [_]*const MiniTable{{}};\n\n", .{msg_name});
        }

        // Generate MiniTable
        // Always use explicit type to allow taking address of the table
        const table_modifier = if (is_self_ref) "pub var" else "pub const";
        try writer.print("{s} {s}_table: MiniTable = .{{\n", .{ table_modifier, msg_name });
        try writer.print("    .fields = &{s}_fields,\n", .{msg_name});
        try writer.print("    .submessages = &{s}_submessages,\n", .{msg_name});
        try writer.print("    .size = {d},\n", .{layout.size});
        try writer.print("    .hasbit_bytes = {d},\n", .{layout.hasbit_bytes});
        try writer.print("    .oneof_count = {d},\n", .{layout.oneof_count});
        try writer.print("    .dense_below = {d},\n", .{layout.dense_below});
        try writer.writeAll("};\n\n");
    } else {
        // No layout computed yet - shouldn't happen in normal flow
        try writer.print("// TODO: layout not computed for {s}\n\n", .{msg.full_name});
    }
}

/// Check if a message is self-referencing (contains itself or ancestor).
fn isSelfReferencing(msg: MessageInfo) bool {
    for (msg.submessages_array) |submsg_name| {
        if (std.mem.eql(u8, submsg_name, msg.full_name)) {
            return true;
        }
    }
    return false;
}

// ============================================================================
// Tests
// ============================================================================

const testing = std.testing;
const expectEqualStrings = testing.expectEqualStrings;

test "generateFile - simple message" {
    const allocator = testing.allocator;

    const FieldLayout = descriptor_parser.FieldLayout;

    var fields = [_]FieldInfo{
        .{
            .name = "id",
            .number = 1,
            .label = .optional,
            .type = .TYPE_INT32,
            .type_name = "",
        },
    };

    var layout_fields = [_]FieldLayout{
        .{
            .number = 1,
            .offset = 0,
            .presence = 1,
            .submsg_index = 65535,
            .field_type = .TYPE_INT32,
            .mode = .scalar,
            .is_packed = false,
                    },
    };

    var msg = MessageInfo{
        .name = "Test",
        .full_name = ".test.Test",
        .fields = fields[0..],
        .nested_messages = &.{},
        .nested_enums = &.{},
        .oneofs = &.{},
        .layout = LayoutInfo{
            .size = 4,
            .hasbit_bytes = 1,
            .oneof_count = 0,
            .dense_below = 1,
            .fields = layout_fields[0..],
        },
    };

    const file = FileInfo{
        .name = "test.proto",
        .package = "test",
        .messages = @as([*]MessageInfo, @ptrCast(&msg))[0..1],
        .enums = &.{},
        .dependencies = &.{},
    };

    const gen = try generateFile(file, allocator);
    defer {
        allocator.free(gen.name);
        allocator.free(gen.content);
    }

    // Verify filename
    try expectEqualStrings("test.pb.zig", gen.name);

    // Verify content contains key elements
    try testing.expect(std.mem.indexOf(u8, gen.content, "// Generated by protoc-gen-zig-pb") != null);
    try testing.expect(std.mem.indexOf(u8, gen.content, "test_table") != null);
    try testing.expect(std.mem.indexOf(u8, gen.content, ".TYPE_INT32") != null);
}

test "generateFile - self-referencing message" {
    const allocator = testing.allocator;

    const FieldLayout = descriptor_parser.FieldLayout;

    var fields = [_]FieldInfo{
        .{
            .name = "next",
            .number = 1,
            .label = .optional,
            .type = .TYPE_MESSAGE,
            .type_name = ".test.Node",
        },
    };

    var layout_fields = [_]FieldLayout{
        .{
            .number = 1,
            .offset = 0,
            .presence = 0,
            .submsg_index = 0,
            .field_type = .TYPE_MESSAGE,
            .mode = .scalar,
            .is_packed = false,
                    },
    };

    var submessages = [_][]const u8{".test.Node"};

    var msg = MessageInfo{
        .name = "Node",
        .full_name = ".test.Node",
        .fields = fields[0..],
        .nested_messages = &.{},
        .nested_enums = &.{},
        .oneofs = &.{},
        .layout = LayoutInfo{
            .size = 8,
            .hasbit_bytes = 0,
            .oneof_count = 0,
            .dense_below = 1,
            .fields = layout_fields[0..],
        },
        .submessages_array = submessages[0..],
    };

    const file = FileInfo{
        .name = "test.proto",
        .package = "test",
        .messages = @as([*]MessageInfo, @ptrCast(&msg))[0..1],
        .enums = &.{},
        .dependencies = &.{},
    };

    const gen = try generateFile(file, allocator);
    defer {
        allocator.free(gen.name);
        allocator.free(gen.content);
    }

    // Verify it uses 'pub var' for self-referencing
    try testing.expect(std.mem.indexOf(u8, gen.content, "pub var node_table: MiniTable") != null);

    // Verify it references itself in submessages
    try testing.expect(std.mem.indexOf(u8, gen.content, "&node_table") != null);
}

test "generateEnum" {
    const allocator = testing.allocator;

    var values = [_]descriptor_parser.EnumValueInfo{
        .{ .name = "UNKNOWN", .number = 0 },
        .{ .name = "FIRST", .number = 1 },
    };

    const enum_info = EnumInfo{
        .name = "MyEnum",
        .full_name = ".test.MyEnum",
        .values = values[0..],
    };

    var buf: std.ArrayList(u8) = .empty;
    defer buf.deinit(allocator);

    try generateEnum(enum_info, buf.writer(allocator), allocator);
    const content = buf.items;

    // Verify enum generation
    try testing.expect(std.mem.indexOf(u8, content, "pub const my_enum = enum(i32)") != null);
    try testing.expect(std.mem.indexOf(u8, content, "unknown = 0") != null);
    try testing.expect(std.mem.indexOf(u8, content, "first = 1") != null);
}
