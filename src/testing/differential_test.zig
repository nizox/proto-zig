//! Differential testing: proto-zig vs upb reference implementation.
//!
//! Compares decode/encode behavior between proto-zig and upb to catch
//! subtle compatibility issues.

const std = @import("std");
const proto = @import("proto");

// Generated proto-zig MiniTable for test schema
const test_message = @import("test_message");

// upb C bindings via amalgamation header
const upb = @cImport({
    @cInclude("upb.h");
    @cInclude("test_message.upb_minitable.h");
    @cInclude("test_message.upb.h");
});

// ============================================================================
// Test Schema: Simple message with common field types
// ============================================================================
//
// From test_message.proto:
//   message TestMessage {
//     int32 field1 = 1;
//     string field2 = 2;
//     int64 field3 = 3;
//   }
//
// MiniTables are generated by:
// - proto-zig: protoc-gen-zig-pb -> test_message.pb.zig
// - upb: protoc-gen-upb_minitable -> test_message.upb_minitable.c

const proto_zig_table: *const proto.MiniTable = &test_message.test_message_table;

// ============================================================================
// Differential Test Helpers
// ============================================================================

const DecodeResult = struct {
    success: bool,
    field1: ?i32 = null,
    field2: ?[]const u8 = null,
    field3: ?i64 = null,
    // Oneof "choice" fields
    oneof_case: u32 = 0, // 0 = not set, 4 = option_a, 5 = option_b
    option_a: ?i32 = null,
    option_b: ?[]const u8 = null,
    // Repeated field
    numbers: ?[]const i32 = null,
    numbers_count: u32 = 0,
};

/// Decode with proto-zig and extract field values
fn protoZigDecode(input: []const u8, arena_buf: []u8) DecodeResult {
    var arena = proto.Arena.init(arena_buf);
    const msg = proto.Message.new(&arena, proto_zig_table) orelse return .{ .success = false };

    proto.decode(input, msg, &arena, .{}) catch return .{ .success = false };

    const f1 = msg.get_scalar(&proto_zig_table.fields[0]);
    const f2 = msg.get_scalar(&proto_zig_table.fields[1]);
    const f3 = msg.get_scalar(&proto_zig_table.fields[2]);

    // Extract oneof case and values (oneof index 0)
    const oneof_case = msg.which_oneof(0);
    var option_a: ?i32 = null;
    var option_b: ?[]const u8 = null;

    if (oneof_case == 4) {
        option_a = msg.get_scalar(&proto_zig_table.fields[3]).int32_val;
    } else if (oneof_case == 5) {
        option_b = msg.get_scalar(&proto_zig_table.fields[4]).string_val.slice();
    }

    // Extract repeated field (field index 5)
    var numbers: ?[]const i32 = null;
    var numbers_count: u32 = 0;
    if (proto_zig_table.fields.len > 5) {
        const repeated_field = msg.get_repeated(&proto_zig_table.fields[5]);
        numbers_count = repeated_field.count;
        if (repeated_field.count > 0 and repeated_field.data != null) {
            const ptr: [*]const i32 = @ptrCast(@alignCast(repeated_field.data.?));
            numbers = ptr[0..repeated_field.count];
        }
    }

    return .{
        .success = true,
        .field1 = f1.int32_val,
        .field2 = f2.string_val.slice(),
        .field3 = f3.int64_val,
        .oneof_case = oneof_case,
        .option_a = option_a,
        .option_b = option_b,
        .numbers = numbers,
        .numbers_count = numbers_count,
    };
}

/// Decode with upb and extract field values
fn upbDecode(input: []const u8) DecodeResult {
    const arena = upb.upb_Arena_New() orelse return .{ .success = false };
    defer upb.upb_Arena_Free(arena);

    // Use generated upb message constructor
    const msg = upb.testing_TestMessage_new(arena) orelse return .{ .success = false };

    // Decode into the typed message
    const table: *const upb.upb_MiniTable = &upb.testing__TestMessage_msg_init;
    const status = upb.upb_Decode(input.ptr, input.len, @ptrCast(msg), table, null, 0, arena);
    if (status != upb.kUpb_DecodeStatus_Ok) {
        return .{ .success = false };
    }

    // Extract field values using generated accessors
    const f1 = upb.testing_TestMessage_field1(msg);
    const f2 = upb.testing_TestMessage_field2(msg);
    const f3 = upb.testing_TestMessage_field3(msg);

    // Extract oneof case and values
    const oneof_case: u32 = upb.testing_TestMessage_choice_case(msg);
    var option_a: ?i32 = null;
    var option_b: ?[]const u8 = null;

    if (oneof_case == 4) {
        option_a = upb.testing_TestMessage_option_a(msg);
    } else if (oneof_case == 5) {
        const opt_b = upb.testing_TestMessage_option_b(msg);
        option_b = if (opt_b.size > 0 and opt_b.data != null) opt_b.data[0..opt_b.size] else "";
    }

    // Extract repeated field
    var numbers_size: usize = 0;
    const numbers_ptr = upb.testing_TestMessage_numbers(msg, &numbers_size);
    var numbers: ?[]const i32 = null;
    if (numbers_size > 0 and numbers_ptr != null) {
        numbers = numbers_ptr[0..numbers_size];
    }

    return .{
        .success = true,
        .field1 = f1,
        .field2 = if (f2.size > 0 and f2.data != null) f2.data[0..f2.size] else "",
        .field3 = f3,
        .oneof_case = oneof_case,
        .option_a = option_a,
        .option_b = option_b,
        .numbers = numbers,
        .numbers_count = @intCast(numbers_size),
    };
}

/// Encode with proto-zig
fn protoZigEncode(input: []const u8, arena_buf: []u8) ?[]const u8 {
    var arena = proto.Arena.init(arena_buf);
    const msg = proto.Message.new(&arena, proto_zig_table) orelse return null;

    proto.decode(input, msg, &arena, .{}) catch return null;
    return proto.encode(msg, &arena, .{}) catch null;
}

/// Encode with upb
fn upbEncode(input: []const u8, out_buf: []u8) ?[]const u8 {
    const arena = upb.upb_Arena_New() orelse return null;
    defer upb.upb_Arena_Free(arena);

    const table: *const upb.upb_MiniTable = &upb.testing__TestMessage_msg_init;
    const msg = upb.testing_TestMessage_new(arena) orelse return null;

    if (upb.upb_Decode(input.ptr, input.len, @ptrCast(msg), table, null, 0, arena) != upb.kUpb_DecodeStatus_Ok) {
        return null;
    }

    var out_ptr: [*c]u8 = undefined;
    var out_size: usize = undefined;

    if (upb.upb_Encode(@ptrCast(msg), table, 0, arena, &out_ptr, &out_size) != upb.kUpb_EncodeStatus_Ok) {
        return null;
    }

    if (out_size > out_buf.len) return null;
    @memcpy(out_buf[0..out_size], out_ptr[0..out_size]);
    return out_buf[0..out_size];
}

/// Compare two decode results
fn compareResults(pz: DecodeResult, upb_res: DecodeResult) bool {
    if (pz.success != upb_res.success) return false;
    if (!pz.success) return true; // Both failed, that's a match

    if (pz.field1 != upb_res.field1) return false;
    if (pz.field3 != upb_res.field3) return false;

    // Compare strings
    const pz_str = pz.field2 orelse "";
    const upb_str = upb_res.field2 orelse "";
    if (!std.mem.eql(u8, pz_str, upb_str)) return false;

    // Compare oneof
    if (pz.oneof_case != upb_res.oneof_case) return false;
    if (pz.option_a != upb_res.option_a) return false;

    const pz_opt_b = pz.option_b orelse "";
    const upb_opt_b = upb_res.option_b orelse "";
    if (!std.mem.eql(u8, pz_opt_b, upb_opt_b)) return false;

    // Compare repeated field
    if (pz.numbers_count != upb_res.numbers_count) return false;
    const pz_nums = pz.numbers orelse &[_]i32{};
    const upb_nums = upb_res.numbers orelse &[_]i32{};
    if (!std.mem.eql(i32, pz_nums, upb_nums)) return false;

    return true;
}

// ============================================================================
// Tests
// ============================================================================

test "upb FFI - arena creation" {
    const arena = upb.upb_Arena_New();
    try std.testing.expect(arena != null);
    upb.upb_Arena_Free(arena);
}

test "upb FFI - arena malloc" {
    const arena = upb.upb_Arena_New() orelse return error.ArenaInitFailed;
    defer upb.upb_Arena_Free(arena);

    const ptr = upb.upb_Arena_Malloc(arena, 64);
    try std.testing.expect(ptr != null);
}

test "upb FFI - generated minitable" {
    // Verify the generated MiniTable is accessible
    const table: *const upb.upb_MiniTable = &upb.testing__TestMessage_msg_init;
    _ = table;
    // If we got here, the table is accessible
}

test "differential - decode int32" {
    var arena_buf: [4096]u8 = undefined;

    // field1 = 42
    const input = [_]u8{ 0x08, 0x2a };

    const pz = protoZigDecode(&input, &arena_buf);
    const upb_res = upbDecode(&input);

    try std.testing.expect(pz.success);
    try std.testing.expect(upb_res.success);
    try std.testing.expectEqual(@as(i32, 42), pz.field1.?);
    try std.testing.expectEqual(@as(i32, 42), upb_res.field1.?);
    try std.testing.expect(compareResults(pz, upb_res));
}

test "differential - decode string" {
    var arena_buf: [4096]u8 = undefined;

    // field2 = "hello"
    const input = [_]u8{ 0x12, 0x05, 'h', 'e', 'l', 'l', 'o' };

    const pz = protoZigDecode(&input, &arena_buf);
    const upb_res = upbDecode(&input);

    try std.testing.expect(pz.success);
    try std.testing.expect(upb_res.success);
    try std.testing.expectEqualStrings("hello", pz.field2.?);
    try std.testing.expectEqualStrings("hello", upb_res.field2.?);
    try std.testing.expect(compareResults(pz, upb_res));
}

test "differential - decode int64" {
    var arena_buf: [4096]u8 = undefined;

    // field3 = 12345
    const input = [_]u8{ 0x18, 0xb9, 0x60 };

    const pz = protoZigDecode(&input, &arena_buf);
    const upb_res = upbDecode(&input);

    try std.testing.expect(pz.success);
    try std.testing.expect(upb_res.success);
    try std.testing.expectEqual(@as(i64, 12345), pz.field3.?);
    try std.testing.expectEqual(@as(i64, 12345), upb_res.field3.?);
    try std.testing.expect(compareResults(pz, upb_res));
}

test "differential - decode all fields" {
    var arena_buf: [4096]u8 = undefined;

    // field1=42, field2="hello", field3=12345
    const input = [_]u8{
        0x08, 0x2a, // field 1: varint 42
        0x12, 0x05, 'h', 'e', 'l', 'l', 'o', // field 2: string "hello"
        0x18, 0xb9, 0x60, // field 3: varint 12345
    };

    const pz = protoZigDecode(&input, &arena_buf);
    const upb_res = upbDecode(&input);

    try std.testing.expect(pz.success);
    try std.testing.expect(upb_res.success);

    try std.testing.expectEqual(@as(i32, 42), pz.field1.?);
    try std.testing.expectEqual(@as(i32, 42), upb_res.field1.?);

    try std.testing.expectEqualStrings("hello", pz.field2.?);
    try std.testing.expectEqualStrings("hello", upb_res.field2.?);

    try std.testing.expectEqual(@as(i64, 12345), pz.field3.?);
    try std.testing.expectEqual(@as(i64, 12345), upb_res.field3.?);

    try std.testing.expect(compareResults(pz, upb_res));

    std.debug.print("Differential decode test passed: all fields match!\n", .{});
}

test "differential - roundtrip encode" {
    var pz_arena: [4096]u8 = undefined;
    var upb_out: [4096]u8 = undefined;

    // field1=42, field2="hello", field3=12345
    const input = [_]u8{
        0x08, 0x2a, // field 1: varint 42
        0x12, 0x05, 'h', 'e', 'l', 'l', 'o', // field 2: string "hello"
        0x18, 0xb9, 0x60, // field 3: varint 12345
    };

    const pz_encoded = protoZigEncode(&input, &pz_arena);
    const upb_encoded = upbEncode(&input, &upb_out);

    try std.testing.expect(pz_encoded != null);
    try std.testing.expect(upb_encoded != null);

    // Both should produce the same output
    try std.testing.expectEqualSlices(u8, pz_encoded.?, upb_encoded.?);

    std.debug.print("Differential roundtrip test passed: encoded outputs match!\n", .{});
}

test "differential - negative varint" {
    var arena_buf: [4096]u8 = undefined;

    // field1 = -1 (encoded as 10-byte varint for int32)
    const input = [_]u8{ 0x08, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01 };

    const pz = protoZigDecode(&input, &arena_buf);
    const upb_res = upbDecode(&input);

    try std.testing.expect(pz.success);
    try std.testing.expect(upb_res.success);
    try std.testing.expectEqual(@as(i32, -1), pz.field1.?);
    try std.testing.expectEqual(@as(i32, -1), upb_res.field1.?);
    try std.testing.expect(compareResults(pz, upb_res));
}

test "differential - empty message" {
    var arena_buf: [4096]u8 = undefined;

    // Empty input - all fields should have default values
    const input = [_]u8{};

    const pz = protoZigDecode(&input, &arena_buf);
    const upb_res = upbDecode(&input);

    try std.testing.expect(pz.success);
    try std.testing.expect(upb_res.success);

    // Default values for proto3: 0, "", 0
    try std.testing.expectEqual(@as(i32, 0), pz.field1.?);
    try std.testing.expectEqual(@as(i32, 0), upb_res.field1.?);
    try std.testing.expectEqual(@as(i64, 0), pz.field3.?);
    try std.testing.expectEqual(@as(i64, 0), upb_res.field3.?);

    try std.testing.expect(compareResults(pz, upb_res));
}

test "differential - unknown field" {
    var arena_buf: [4096]u8 = undefined;

    // field1=42, unknown field 99=123, field3=12345
    const input = [_]u8{
        0x08, 0x2a, // field 1: varint 42
        0xf8, 0x06, 0x7b, // field 99: varint 123 (unknown)
        0x18, 0xb9, 0x60, // field 3: varint 12345
    };

    const pz = protoZigDecode(&input, &arena_buf);
    const upb_res = upbDecode(&input);

    // Both should succeed and parse known fields
    try std.testing.expect(pz.success);
    try std.testing.expect(upb_res.success);
    try std.testing.expectEqual(@as(i32, 42), pz.field1.?);
    try std.testing.expectEqual(@as(i32, 42), upb_res.field1.?);
    try std.testing.expectEqual(@as(i64, 12345), pz.field3.?);
    try std.testing.expectEqual(@as(i64, 12345), upb_res.field3.?);
}

test "differential - out of order fields" {
    var arena_buf: [4096]u8 = undefined;

    // Fields in reverse order: field3, field2, field1
    const input = [_]u8{
        0x18, 0xb9, 0x60, // field 3: varint 12345
        0x12, 0x05, 'h', 'e', 'l', 'l', 'o', // field 2: string "hello"
        0x08, 0x2a, // field 1: varint 42
    };

    const pz = protoZigDecode(&input, &arena_buf);
    const upb_res = upbDecode(&input);

    try std.testing.expect(pz.success);
    try std.testing.expect(upb_res.success);
    try std.testing.expect(compareResults(pz, upb_res));
}

test "differential - oneof option_a (int32)" {
    var arena_buf: [4096]u8 = undefined;

    // option_a = 99 (field 4)
    const input = [_]u8{ 0x20, 0x63 }; // tag 4, varint 99

    const pz = protoZigDecode(&input, &arena_buf);
    const upb_res = upbDecode(&input);

    try std.testing.expect(pz.success);
    try std.testing.expect(upb_res.success);
    try std.testing.expectEqual(@as(u32, 4), pz.oneof_case);
    try std.testing.expectEqual(@as(u32, 4), upb_res.oneof_case);
    try std.testing.expectEqual(@as(i32, 99), pz.option_a.?);
    try std.testing.expectEqual(@as(i32, 99), upb_res.option_a.?);
    try std.testing.expect(compareResults(pz, upb_res));
}

test "differential - oneof option_b (string)" {
    var arena_buf: [4096]u8 = undefined;

    // option_b = "test" (field 5)
    const input = [_]u8{ 0x2a, 0x04, 't', 'e', 's', 't' }; // tag 5, string "test"

    const pz = protoZigDecode(&input, &arena_buf);
    const upb_res = upbDecode(&input);

    try std.testing.expect(pz.success);
    try std.testing.expect(upb_res.success);
    try std.testing.expectEqual(@as(u32, 5), pz.oneof_case);
    try std.testing.expectEqual(@as(u32, 5), upb_res.oneof_case);
    try std.testing.expectEqualStrings("test", pz.option_b.?);
    try std.testing.expectEqualStrings("test", upb_res.option_b.?);
    try std.testing.expect(compareResults(pz, upb_res));
}

test "differential - oneof last value wins" {
    var arena_buf: [4096]u8 = undefined;

    // option_a = 42, then option_b = "win" - last value should win
    const input = [_]u8{
        0x20, 0x2a, // option_a = 42 (field 4)
        0x2a, 0x03, 'w', 'i', 'n', // option_b = "win" (field 5)
    };

    const pz = protoZigDecode(&input, &arena_buf);
    const upb_res = upbDecode(&input);

    try std.testing.expect(pz.success);
    try std.testing.expect(upb_res.success);
    try std.testing.expectEqual(@as(u32, 5), pz.oneof_case);
    try std.testing.expectEqual(@as(u32, 5), upb_res.oneof_case);
    try std.testing.expectEqualStrings("win", pz.option_b.?);
    try std.testing.expectEqualStrings("win", upb_res.option_b.?);
    try std.testing.expect(pz.option_a == null);
    try std.testing.expect(upb_res.option_a == null);
    try std.testing.expect(compareResults(pz, upb_res));
}

test "differential - oneof with regular fields" {
    var arena_buf: [4096]u8 = undefined;

    // field1=42, option_a=99, field3=12345
    const input = [_]u8{
        0x08, 0x2a, // field 1: varint 42
        0x20, 0x63, // option_a = 99 (field 4)
        0x18, 0xb9, 0x60, // field 3: varint 12345
    };

    const pz = protoZigDecode(&input, &arena_buf);
    const upb_res = upbDecode(&input);

    try std.testing.expect(pz.success);
    try std.testing.expect(upb_res.success);
    try std.testing.expectEqual(@as(i32, 42), pz.field1.?);
    try std.testing.expectEqual(@as(i32, 42), upb_res.field1.?);
    try std.testing.expectEqual(@as(i64, 12345), pz.field3.?);
    try std.testing.expectEqual(@as(i64, 12345), upb_res.field3.?);
    try std.testing.expectEqual(@as(u32, 4), pz.oneof_case);
    try std.testing.expectEqual(@as(u32, 4), upb_res.oneof_case);
    try std.testing.expectEqual(@as(i32, 99), pz.option_a.?);
    try std.testing.expectEqual(@as(i32, 99), upb_res.option_a.?);
    try std.testing.expect(compareResults(pz, upb_res));
}

test "differential - repeated int32 single element" {
    var arena_buf: [4096]u8 = undefined;

    // numbers = [42] - single element, non-packed
    // tag 6, wire type 0 (varint) = 0x30
    const input = [_]u8{ 0x30, 0x2a };

    const pz = protoZigDecode(&input, &arena_buf);
    const upb_res = upbDecode(&input);

    try std.testing.expect(pz.success);
    try std.testing.expect(upb_res.success);
    try std.testing.expectEqual(@as(u32, 1), pz.numbers_count);
    try std.testing.expectEqual(@as(u32, 1), upb_res.numbers_count);
    try std.testing.expectEqual(@as(i32, 42), pz.numbers.?[0]);
    try std.testing.expectEqual(@as(i32, 42), upb_res.numbers.?[0]);
    try std.testing.expect(compareResults(pz, upb_res));
}

test "differential - repeated int32 multiple non-packed" {
    var arena_buf: [4096]u8 = undefined;

    // numbers = [1, 2, 3] - multiple elements, non-packed
    const input = [_]u8{
        0x30, 0x01, // numbers[0] = 1
        0x30, 0x02, // numbers[1] = 2
        0x30, 0x03, // numbers[2] = 3
    };

    const pz = protoZigDecode(&input, &arena_buf);
    const upb_res = upbDecode(&input);

    try std.testing.expect(pz.success);
    try std.testing.expect(upb_res.success);
    try std.testing.expectEqual(@as(u32, 3), pz.numbers_count);
    try std.testing.expectEqual(@as(u32, 3), upb_res.numbers_count);
    try std.testing.expectEqualSlices(i32, &[_]i32{ 1, 2, 3 }, pz.numbers.?);
    try std.testing.expectEqualSlices(i32, &[_]i32{ 1, 2, 3 }, upb_res.numbers.?);
    try std.testing.expect(compareResults(pz, upb_res));
}

test "differential - repeated int32 packed" {
    var arena_buf: [4096]u8 = undefined;

    // numbers = [1, 2, 3] - packed encoding
    // tag 6, wire type 2 (length-delimited) = 0x32
    const input = [_]u8{
        0x32, 0x03, // tag 6, length 3
        0x01, // 1
        0x02, // 2
        0x03, // 3
    };

    const pz = protoZigDecode(&input, &arena_buf);
    const upb_res = upbDecode(&input);

    try std.testing.expect(pz.success);
    try std.testing.expect(upb_res.success);
    try std.testing.expectEqual(@as(u32, 3), pz.numbers_count);
    try std.testing.expectEqual(@as(u32, 3), upb_res.numbers_count);
    try std.testing.expectEqualSlices(i32, &[_]i32{ 1, 2, 3 }, pz.numbers.?);
    try std.testing.expectEqualSlices(i32, &[_]i32{ 1, 2, 3 }, upb_res.numbers.?);
    try std.testing.expect(compareResults(pz, upb_res));
}

test "differential - repeated int32 with other fields" {
    var arena_buf: [4096]u8 = undefined;

    // field1=42, numbers=[10, 20, 30], field3=999
    const input = [_]u8{
        0x08, 0x2a, // field 1: varint 42
        0x32, 0x03, 0x0a, 0x14, 0x1e, // numbers: packed [10, 20, 30]
        0x18, 0xe7, 0x07, // field 3: varint 999
    };

    const pz = protoZigDecode(&input, &arena_buf);
    const upb_res = upbDecode(&input);

    try std.testing.expect(pz.success);
    try std.testing.expect(upb_res.success);
    try std.testing.expectEqual(@as(i32, 42), pz.field1.?);
    try std.testing.expectEqual(@as(i32, 42), upb_res.field1.?);
    try std.testing.expectEqual(@as(i64, 999), pz.field3.?);
    try std.testing.expectEqual(@as(i64, 999), upb_res.field3.?);
    try std.testing.expectEqual(@as(u32, 3), pz.numbers_count);
    try std.testing.expectEqual(@as(u32, 3), upb_res.numbers_count);
    try std.testing.expectEqualSlices(i32, &[_]i32{ 10, 20, 30 }, pz.numbers.?);
    try std.testing.expectEqualSlices(i32, &[_]i32{ 10, 20, 30 }, upb_res.numbers.?);
    try std.testing.expect(compareResults(pz, upb_res));

    std.debug.print("Differential repeated field test passed!\n", .{});
}

test "differential - repeated int32 empty" {
    var arena_buf: [4096]u8 = undefined;

    // Empty message - no repeated field data
    const input = [_]u8{};

    const pz = protoZigDecode(&input, &arena_buf);
    const upb_res = upbDecode(&input);

    try std.testing.expect(pz.success);
    try std.testing.expect(upb_res.success);
    try std.testing.expectEqual(@as(u32, 0), pz.numbers_count);
    try std.testing.expectEqual(@as(u32, 0), upb_res.numbers_count);
    try std.testing.expect(compareResults(pz, upb_res));
}
